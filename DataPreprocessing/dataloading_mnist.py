# -*- coding: utf-8 -*-
"""DataLoading_MNIST.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19Uh_6iEMzfesU6wOYw3qm-9iXhG9S27O

Lets start with the basic of loading MNIST data
"""

#interating with the drive so that you dont have to upload data everytime you use it
# from google.colab import drive
# drive.mount('/content/drive')

#check what is your current working director -- generally its /content
# pwd

#check if you can access the data directory - by looking into the content of the directory
# !ls "/content/drive/MyDrive/Colab Notebooks/datasets/MNIST_Data"

#importing torch
import torch

"""IDX file format: a simple format for vectors and multidimensional matrices of various numerical types. It is a binary format - sequence of bytes (8 bit - sequence of 0s and 1s); most efficient and compact way to store data

IDX file format is the Orginal file format for MNIST dataset

Dataset link
- orignal: https://yann.lecun.com/exdb/mnist/
- Kaggle: https://www.kaggle.com/datasets/hojjatk/mnist-dataset



MNIST is a set of 70,000 images of handwritten digits (‘0’ through ‘9’). Each image is 28 pixels by 28 pixels. Each pixel is a grayscale value between 0 and 255.

There are 60,000 images designated for training (6,000 of each digit) and 10,000 images designated for training (1,000 of each digit).


"""

#pytorch library used to convert idx format to numpy
# !pip install idx2numpy

import idx2numpy
import os

#specify the initial path of the directory
initial_path = '/content/drive/MyDrive/Colab Notebooks/datasets/MNIST_Data' #replace this with your directory path

#convert the idx files to numpy arrays
data_test = idx2numpy.convert_from_file(os.path.join(initial_path,'t10k-images.idx3-ubyte')) #replace this with your file path/name
label_test = idx2numpy.convert_from_file(os.path.join(initial_path,'t10k-labels.idx1-ubyte'))
data_train = idx2numpy.convert_from_file(os.path.join(initial_path,'train-images.idx3-ubyte'))
label_train = idx2numpy.convert_from_file(os.path.join(initial_path,'train-labels.idx1-ubyte'))

#.shape: tells you the structure of the array (how many rows, columns, etc.)
#.size: tells you the total number of elements in the array .
print(f"the structure of the test data is : {data_test.shape} and the size is : {data_test.size}")
print(f"the structure of the train data is : {data_train.shape} and the size is : {data_train.size}")

#lets see how one data point looks like
print(f"the first data point is : {data_train[0]} and its label is {label_train[0]} ")

"""Coverting numpy array to tensors because,  
- In PyTorch tensors are used to encode the inputs and outputs of a model, as well as the model’s parameters.
- PyTorch provides a rich set of operations specifically designed for tensors, enabling efficient computations and manipulations.
"""

# Convert to PyTorch tensor
data_test_tensor =  torch.from_numpy(data_test)
label_test_tensor = torch.from_numpy(label_test)
data_train_tensor = torch.from_numpy(data_train)
label_train_tensor = torch.from_numpy(label_train)

#lets find various attributes of the tensor
print(f"the device tensor is stored on is : {data_test_tensor.device}")
print(f"the type of the tensor is : {data_test_tensor.dtype}")
print(f"the size of the test data is : {data_test_tensor.shape}") #alternative is data_test_tensor.size()

#to move tensor to GPU
if torch.cuda.is_available(): #first thing is to check if GPU is available
  data_test_tensor = data_test_tensor.to('cuda')
  print(f"the device tensor is stored on is : {data_test_tensor.device}")
else:
  print("GPU is not available")

"""Tensor operations : by default all operators are row wise (dim=0), if you want to do column wise then specify (dim=1)

"""

